Архитектурная структура LWP v2.3
Проект строится на принципе разделения ответственности (Separation of Concerns). Мы разделяем логику упаковки данных, управление ссылками и ввод-вывод.
1. Дерево каталогов
code
Text
.
├── src-lua/
│   ├── init.lua            # Точка входа (собирает пакет)
│   ├── constants.lua       # Карта байтов (v2.3)
│   ├── registry.lua        # Реестр внешних объектов
│   ├── serializer.lua      # Движок записи (Stream-based)
│   ├── deserializer.lua    # Движок чтения (Stream-based)
│   ├── codec.lua           # Фасад (High-level API)
│   ├── string_writer.lua   # Буфер для записи в строку
│   ├── string_reader.lua   # Поток для чтения из строки
│   └── utils.lua           # Вспомогательные функции
├── build/                  # Скомпилированная библиотека
├── Makefile                # Сборка и тесты
└── sample.lua              # Пример использования
2. Основные компоненты и их роли
Codec (Фасад): Главный объект, с которым взаимодействует пользователь.
Владеет экземплярами Serializer и Deserializer.
Гарантирует, что оба движка используют один и тот же экземпляр Registry.
Предоставляет удобные методы encode/decode для работы со строками.
Serializer & Deserializer (Движки):
Stateless: Сами объекты движков хранят только настройки и реестр.
Context-driven: Состояние конкретной операции (таблицы seen, счетчики ref_counter) создается внутри метода write/read и уничтожается после выхода из него.
Routing: Используют таблицы переходов (dispatch) для быстрого выбора функции обработки типа (у Serializer — по type(), у Deserializer — по байту заголовка).
Registry (Управление ссылками):
Хранит объекты, которые нельзя сериализовать (функции, userdata).
Реализует автоинкремент ID (начиная с 0).
Позволяет делать unregister по значению объекта.
Writer & Reader (Абстракция I/O):
Позволяют Serializer'у не знать, куда он пишет (в строку, файл или сокет).
StringWriter использует table.concat для эффективности.
StringReader инкапсулирует pos и управляет смещением при вызовах string.unpack.
3. Жизненный цикл вызова
Кодирование (Codec:encode):
Создается StringWriter.
В Serializer:write создается ctx (контекст с пустой таблицей seen и ref_counter = 0).
Запускается рекурсивный обход данных.
seen наполняется по принципу [table_ref] = id.
По завершении StringWriter отдает готовую строку.
Декодирование (Codec:decode):
Создается StringReader из входящей строки.
В Deserializer:read создается ctx (контекст с пустой таблицей seen и ref_counter = 0).
Запускается цикл чтения байтов заголовка.
seen наполняется по принципу [id] = table_ref.
При встрече Link движок сначала ищет ID в Registry, затем в seen.
Ключевое решение по импортам:
Использование local module_path = (...):match("(.-)[^%.]+$") позволяет библиотеке быть полностью автономной и переносимой внутри любой файловой структуры.
