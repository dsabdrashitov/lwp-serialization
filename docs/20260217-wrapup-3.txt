Блок №3 — Реализованные базовые модули. Это готовый код вспомогательных классов, которые обеспечивают работу движков и I/O. Все модули используют относительные пути для переносимости.
1. src-lua/constants.lua
Определяет «скелет» протокола v2.3.
code
Lua
-- LWP-Serialization v2.3 (The "Anchor" Edition)
local Constants = {
    NIL         = 0x00, -- Also table terminator
    FALSE       = 0x01,
    TRUE        = 0x02,
    FLOAT64     = 0x03,
    
    I8          = 0x04, I16 = 0x05, I32 = 0x06, I64 = 0x07,
    STR_I1      = 0x08, STR_I2 = 0x09, STR_I4 = 0x0A, STR_I8 = 0x0B,
    LNK_I1      = 0x0C, LNK_I2 = 0x0D, LNK_I4 = 0x0E, LNK_I8 = 0x0F,

    SMALL_STR_START = 0x10, -- 0x10...0x4F (len 0..63)
    SMALL_LNK_START = 0x50, -- 0x50...0x8F (ID 0..63)
    SMALL_INT_START = 0x90, -- 0x90...0xFE (val 0..110)

    TABLE_START     = 0xFF, -- The Anchor

    MAX_SMALL_STR = 63,
    MAX_SMALL_LNK = 63,
    MAX_SMALL_INT = 110
}
return Constants
2. src-lua/registry.lua
Управляет несериализуемыми объектами с автоинкрементом ID (0-based).
code
Lua
local Registry = {}
Registry.__index = Registry

function Registry:new(initial_map)
    local obj = setmetatable({ obj_to_id = {}, id_to_obj = {}, next_id = 0 }, self)
    if initial_map then
        for id, item in pairs(initial_map) do
            assert(type(id) == "number" and id >= 0, "ID must be non-negative")
            obj.obj_to_id[item] = id
            obj.id_to_obj[id] = item
            if id >= obj.next_id then obj.next_id = id + 1 end
        end
    end
    return obj
end

function Registry:register(obj)
    if self.obj_to_id[obj] then return self.obj_to_id[obj] end
    local id = self.next_id
    self.next_id = self.next_id + 1
    self.obj_to_id[obj], self.id_to_obj[id] = id, obj
    return id
end

function Registry:unregister(obj)
    local id = self.obj_to_id[obj]
    if id then self.id_to_obj[id], self.obj_to_id[obj] = nil, nil end
end

function Registry:get_id(obj) return self.obj_to_id[obj] end
function Registry:get_obj(id) return self.id_to_obj[id] end
return Registry
3. src-lua/string_writer.lua
Эффективная сборка бинарной строки.
code
Lua
local StringWriter = {}
StringWriter.__index = StringWriter

function StringWriter:new()
    return setmetatable({ buffer = {} }, self)
end

function StringWriter:write(data)
    self.buffer[#self.buffer + 1] = data
end

function StringWriter:to_string()
    return table.concat(self.buffer)
end

function StringWriter:reset()
    self.buffer = {}
end

return StringWriter
4. src-lua/string_reader.lua
Потоковое чтение с управлением позицией.
code
Lua
local StringReader = {}
StringReader.__index = StringReader

function StringReader:new(data)
    return setmetatable({ data = data, pos = 1, len = #data }, self)
end

function StringReader:read_byte()
    if self.pos > self.len then return nil end
    local val = string.unpack("<B", self.data, self.pos)
    self.pos = self.pos + 1
    return val
end

function StringReader:unpack(fmt)
    if self.pos > self.len then error("Unexpected EOF") end
    local val, next_pos = string.unpack(fmt, self.data, self.pos)
    self.pos = next_pos
    return val
end

function StringReader:read_raw(length)
    if length <= 0 then return "" end
    if self.pos + length - 1 > self.len then error("EOF in raw read") end
    local val = string.sub(self.data, self.pos, self.pos + length - 1)
    self.pos = self.pos + length
    return val
end

return StringReader
