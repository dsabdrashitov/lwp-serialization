Спецификация протокола LWP-Serialization (v2.3)
Цель: Максимально компактная двоичная передача данных с поддержкой графов (циклических ссылок) и стриминга таблиц.
Порядок байтов: Little-endian (<).
Типы Lua 5.4: Разделение целых (integer) и дробных (float) чисел.
1. Карта заголовков (Header Byte Map)
Каждый элемент начинается с 1 байта заголовка, который определяет тип данных и, в случае "малых" типов, вшитое значение.
Диапазон (Hex)	Категория	Логика интерпретации
0x00	Specials / Term	NIL. Также служит терминатором ключей в таблице.
0x01	Specials	False
0x02	Specials	True
0x03	Specials	Float64 (8 байт IEEE 754)
0x04 - 0x07	Fixed Int	Знаковые целые: 0x04: i8, 0x05: i16, 0x06: i32, 0x07: i64
0x08 - 0x0B	Fixed Str	Длина строки (uint): 0x08: I1, 0x09: I2, 0x0A: I4, 0x0B: I8
0x0C - 0x0F	Fixed Lnk	ID ссылки (uint): 0x0C: I1, 0x0D: I2, 0x0E: I4, 0x0F: I8
0x10 - 0x4F	Small Str	Длина строки = Header - 0x10 (Диапазон: 0..63)
0x50 - 0x8F	Small Lnk	ID ссылки = Header - 0x50 (Диапазон: 0..63)
0x90 - 0xFE	Small Int	Значение целого = Header - 0x90 (Диапазон: 0..110)
0xFF	Table Start	Начало стриминга таблицы.
2. Правила упаковки (Packing Rules)
Numbers:
Integer в диапазоне 0..110 -> Small Int (1 байт).
Integer отрицательный или > 110 -> Fixed Int (Заголовок + 1/2/4/8 байт). Всегда знаковое (i1, i2...).
Float (любой) -> Float64 (0x03 + 8 байт).
Strings:
Длина 0..63 -> Small Str (Заголовок + тело строки).
Длина > 63 -> Fixed Str (Заголовок + байты длины + тело строки).
Links (Ссылки):
Используются для повторных таблиц (циклы) и объектов из Registry.
ID 0..63 -> Small Lnk (1 байт).
ID > 63 -> Fixed Lnk (Заголовок + байты ID).
3. Логика Sentinel-таблиц (Streaming)
Протокол v2.3 отказывается от предварительного подсчета количества элементов (Length-prefixed) в пользу терминирующего байта (Sentinel). Это позволяет сериализовать таблицы за один проход pairs().
Алгоритм записи таблицы:
Записать байт 0xFF (TABLE_START).
Записать объект в реестр seen (присвоить текущий ref_counter).
Итерировать таблицу через pairs():
Записать Ключ (рекурсивно).
Записать Значение (рекурсивно).
Записать байт 0x00 (NIL) в позиции, где ожидается следующий Ключ.
Алгоритм чтения таблицы:
Встретили 0xFF -> Создать пустую таблицу {}.
Добавить её в локальный список seen под текущим id.
Запустить цикл while true:
Прочитать 1 байт заголовка.
Если байт == 0x00 -> Выйти из цикла (конец таблицы).
Если байт != 0x00 -> Десериализовать Ключ (используя уже прочитанный заголовок).
Десериализовать Значение.
Вставить t[key] = value.
Почему это эффективно:
Компактность: Малые целые до 110 и короткие строки теперь всегда занимают минимальное место.
Скорость: Отсутствие двойного прохода по таблицам критично для производительности в Lua.
Наглядность: Байт 0xFF служит четким визуальным маркером начала сложной структуры в дампе данных.
